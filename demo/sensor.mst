{{#features}}
	<li id="{{feature_ol_uid}}" class="inventaire item" style="height: 300px;">
        <p>
            <b>Feature ol uid : </b> {{feature_ol_uid}}
        </p>
        
        {{#observations}}
            <p>
                <b>Streams sélectionnés : </b> {{streamsNames}}
            </p>
        {{/observations}}
        <div class="chart-container" style="position: relative; margin: auto; height: 250px; width:80vh">
            <canvas id="chart"></canvas>
        </div>
    </li>
    <script>

    function getRandomColor() {
        var letters = '0123456789ABCDEF'.split('');
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.round(Math.random() * 15)];
        }
        return color;
    }

    const mvLayer = _.keys(mviewer.getLayers()).filter(k => mviewer.getLayer(k).type === "sensorthings")[0];
    let featureWithObservations = mviewer.getLayer(mvLayer).layer.getSource().getFeatures().filter(x => x.ol_uid === mviewer.sensorthings.featureIdSelected);
    const props = featureWithObservations[0].getProperties();
    
    const streamsObs = mviewer.sensorthings.selected.map(x => parseInt(x));
    let streamsId = streamsObs[0];
    const firstDatastreamObservation = props.observations[streamsId].result;
    let datesValues = firstDatastreamObservation.map(o => new Date(o.resultTime).toLocaleDateString());
    let datasets = [];
    if(mviewer.sensorthings.datastreams && mviewer.sensorthings.datastreams.length) {
        datasets.push(
            streamsObs.map(data => {
                let observations = props.observations[data].result;
                let yValues = observations.map(o => o.result);
                let randomColor = getRandomColor();
                const streams = mviewer.sensorthings.datastreams;
                return {
                    label: streams.filter(x => x.id === data)[0]?.name,
                    data: yValues,
                    borderWidth: 1.5,
                    borderColor: randomColor,
                    backgroundColor: randomColor,
                    fill: false
                }
            })
        )
    }
    if(mviewer.sensorthings.multidatastreams && mviewer.sensorthings.multidatastreams.length) {
        streamsObs.map(data => {
            let observations = props.observations[data].result;
            let yValues = observations.map(o => o.result);
            const streams = mviewer.sensorthings.multidatastreams;
            let unitOfMeasures = mviewer.sensorthings.multidatastreams[0].unitOfMeasurements.map(x => x.name);
            let unitOfMeasurementsDataset = unitOfMeasures.map(unit => {
                let randomColor = getRandomColor();
                return {
                    data: observations.map(o => o.result[unit]),
                    label: unit,
                    borderWidth: 1.5,
                    borderColor: randomColor,
                    backgroundColor: randomColor,
                    fill: false
                }
            });
            datasets = [...datasets, ... unitOfMeasurementsDataset]
        })
        
    }

    var config = {
        type: 'line',
        data: {
            labels: datesValues,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false
        }
    }
    var ctx = document.getElementById('chart').getContext('2d');
    new Chart(ctx, config);
    </script>
{{/features}}